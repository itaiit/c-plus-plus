## 动态内存与智能指针

初始化的方式：默认初始化，值初始化，列表初始化，直接初始化。

### 动态对象默认初始化`new int`



### 动态对象直接初始化`new int()`

而对于动态对象的直接初始化：

```c++
int *pint = new int();
string *pstr = new string("hello world");
```

直接初始化在对象类型后面加上`()`，参数则是某一个可以匹配到的构造函数的其中一种形式。

> 空指针可以被多次释放。

### 智能指针

#### `shared_ptr`

##### `get()`

不要使用`get()`方法为另一个智能指针赋值，这样会使两个智能指针指向相同的一块内存空间，由于智能指针超出其作用域之后会自动释放内存空间，因此，会导致内存空间的二次释放。

_`get()`函数的设计用来为不能使用智能指针的代码传递一个内置指针_。

##### `reset()`

智能指针的`reset`操作常与`unique()`一起使用，来判断是否还有其它的智能指针指向相同的内存空间：

```c++
	shared_ptr<int> p(new int(10));
	cout << boolalpha << p.unique() << endl; // true
```

##### 使用智能指针的陷阱

如果使用智能指针管理的资源不是new分配的内存，记住要传递给它一个删除器，在内存销毁时，则会执行指定的删除器。

#### `unique_ptr`

初始化必须采用_直接初始化_的方式，不支持拷贝和赋值，但存在例外的情况：函数传入或者返回一个unique_ptr类型的参数。

值得注意的时`release()`和`reset()`操作：

`p.release()`操作先返回p所指向的内存空间的一个指针，然后将p置为空。

#### `weak_ptr`